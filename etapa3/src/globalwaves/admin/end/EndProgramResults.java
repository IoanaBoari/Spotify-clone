package globalwaves.admin.end;

import fileio.input.SongInput;
import fileio.input.UserInput;
import globalwaves.Database;
import globalwaves.user.artist.Album;
import globalwaves.user.artist.Artist;
import globalwaves.user.artist.merch.Merch;
import globalwaves.user.artist.merch.OwnedMerch;
import globalwaves.userstats.Listener;

public final class EndProgramResults implements Comparable<EndProgramResults> {
    private final Double credit = 1000000.0;
    private final Double round = 100.0;
    private String username;
    private double songRevenue;
    private double merchRevenue;
    private String mostProfitableSong;
    private Integer ranking;

    public String getUsername() {
        return username;
    }

    public void setUsername(final String username) {
        this.username = username;
    }

    public double getSongRevenue() {
        return songRevenue;
    }

    public void setSongRevenue(final double songRevenue) {
        this.songRevenue = songRevenue;
    }

    public double getMerchRevenue() {
        return merchRevenue;
    }

    public void setMerchRevenue(final double merchRevenue) {
        this.merchRevenue = merchRevenue;
    }

    public String getMostProfitableSong() {
        return mostProfitableSong;
    }

    public void setMostProfitableSong(final String mostProfitableSong) {
        this.mostProfitableSong = mostProfitableSong;
    }

    public Integer getRanking() {
        return ranking;
    }

    public void setRanking(final Integer ranking) {
        this.ranking = ranking;
    }

    public EndProgramResults() {
    }

    /**
     * Compares this EndProgramResults object with another object of the same type.
     * Comparison is based on the total revenue, which is the sum of songRevenue and merchRevenue,
     * in descending order. If total revenues are equal, the objects are sorted alphabetically
     * based on the usernames.
     *
     * @param other The EndProgramResults object to compare with.
     * @return A negative integer, zero, or a positive integer as this object is less than,
     * equal to, or greater than the specified object.
     */
    @Override
    public int compareTo(final EndProgramResults other) {
        // Comparison in descending order based on the sum of songRevenue and merchRevenue
        double thisTotalRevenue = this.getSongRevenue() + this.getMerchRevenue();
        double otherTotalRevenue = other.getSongRevenue() + other.getMerchRevenue();

        // Descending comparison based on totalRevenue
        int revenueComparison = Double.compare(otherTotalRevenue, thisTotalRevenue);

        // If totalRevenues are equal, sort alphabetically
        if (revenueComparison == 0) {
            String thisName = this.getUsername();
            String otherName = other.getUsername();
            return thisName.compareTo(otherName);
        }

        return revenueComparison;
    }
    public EndProgramResults(final String artist) {
    this.username = artist;
    this.songRevenue = calculateSongRevenue(artist);
    this.merchRevenue = calculateMerchRevenue(artist);
    this.mostProfitableSong = calculateMostProfitableSong(artist);
    }

    /**
     * Calculates the song revenue generated by a specific artist, considering both
     * premium listener payments and ad revenues.
     *
     * @param artist The name of the artist for whom the song revenue is calculated.
     * @return The total revenue generated by the artist's songs, including
     * both premium listener payments and ad revenues.
     * The result is rounded based on the specified precision.
     */
    public double calculateSongRevenue(final String artist) {
        double revenue = 0.0;
        for (Listener listener : Database.getInstance().getPremiumListeners()) {
            for (SongInput song : listener.getSongsloaded()) {
                if (song.getArtist().equals(artist)) {
                    revenue += (credit / listener.getSongsloaded().size());
                    song.setRevenue(song.getRevenue()
                            + (credit / listener.getSongsloaded().size()));
                }
            }
        }
        if (Database.getInstance().getAdRevenues().containsKey(artist)) {
            double currentRevenue = Database.getInstance().getAdRevenues().get(artist);
            revenue += currentRevenue;
        }
        revenue = Math.round(revenue * round) / round;
        return revenue;
    }

    /**
     * Calculates the total merchandise revenue for a specific artist
     * based on the prices of owned merchandise.
     *
     * @param artist The name of the artist for whom the merchandise revenue is calculated.
     * @return The total revenue generated by the artist's owned merchandise,
     * summing up the prices of each item.
     *         The result is rounded based on the specified precision.
     */
    public double calculateMerchRevenue(final String artist) {
        double revenue = 0.0;
        for (OwnedMerch ownedMerch : Database.getInstance().getOwnedMerchArrayList()) {
            for (Merch merch : ownedMerch.getOwnedmerchandise()) {
                if (merch.getUsername().equals(artist)) {
                    revenue += merch.getPrice();
                }
            }
        }
        revenue = Math.round(revenue * round) / round;
        return revenue;
    }

    /**
     * Calculates the name of the most profitable song for a specific artist
     * based on song revenues.
     *
     * @param artist The name of the artist for whom the most profitable song is calculated.
     * @return The name of the most profitable song for the specified artist.
     * If no profitable song is found, returns "N/A".
     */
    public String calculateMostProfitableSong(final String artist) {
        SongInput mostProfitableSong = null;
        UserInput currentuser = null;
        for (UserInput user : Database.getInstance().getLibrary().getUsers()) {
            if (user.getUsername().equals(artist)) {
                currentuser = user;
                break;
            }
        }
        Artist currentArtist = (Artist) currentuser;
        for (Album album : currentArtist.getAlbums()) {
            for (SongInput song : album.getSongs()) {
                if (song.getRevenue() > 0.0 && (mostProfitableSong == null
                        || mostProfitableSong.getRevenue() < song.getRevenue())) {
                    mostProfitableSong = song;
                }
            }
        }
        if (mostProfitableSong == null) {
            return "N/A";
        } else {
            return mostProfitableSong.getName();
        }
    }
}
